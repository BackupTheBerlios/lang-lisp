Note that there are TODOs in here, this is due to the early stage of Langs development.

<h2>What it is/what it wants to be</h2>

<p>Lang is meant to be different then earlier lisps(and languages) in its type system
and how the user interacts with it. It uses function overloading for functions and 
macros.</p>

<p>One of the goals of Lang is to have as much as possible either be
 a library, or written in a very library-like manner, modularly. The specification should be
the same way. As such, i attempt to make Lang able to incorporate other programming 
methods and concepts via libraries as well.</p>

<h3>Syntax</h3>
Lang is written in trees like a lisp. However, it is still open alternative 
ways to produce these trees. But it must always be clear what 
tree the syntax creates. (See 'Alternative ideas for syntax'.) <!-- TODO link it to end. -->


<h3>Functional types</h3>
<p>Functional types are the most important idea in Lang. Structures are written 
as having arguments, which are used for the types of its elements, in which
the arguments are filled in, with both full types and the arguments the structure
itself takes. Like this: <code>(struct list-node (item-type)
  (next (ptr (list-node item-type))) (item item-type))</code>
Of course, you can't make it circularly, but the pointer here prevents it from 
being so. Also note that you can do stuff like give initial values, keywords for 
setting at creation, and class derivation with keywords. TODO last sentence</p>

<p>If you define a structure, any of its more specific types can be created. 
(I might call more specific finer and more general coarser.) A type is more 
specific then another type when you can equal the finer one by
 filling an argument. However, there are exceptions, for instance, <code>(any)</code>
is a type that is always more general, number types are set manually, and there will be
types like </code>or</code> and </code>eql</code>. Of course, all the deviate types need to be internally 
consistent. <!-- TODO make and link to number types, or. -->
</p>

<h3>Selection based on types</h3>
<p>Lang uses function overloading, this is also a subset of type inference. For functions,
it will look into multiple of the same name, and will pick one of the most specific.
It says one of, there because it might be ambiguous if you only look at the 
specificness. For this reason, Lang has a preference in types, of always seeking the function
with the most specific rightmost. However, users should try to avoid making this type-preference 
an issue when actually coding. This means trying to keep down the number of arguments, 
or making the more specific cases just more efficient versions of the same.</p>
<p>Note that macros can use type selection as wel, in a way identical to that of functions,
but only for a fixed ammount of arguments at the beginning.</p>
<!-- <p>Structure -functions/-macros themselves use type selection for get-slot. 
Again, the most specific, using the preference, is used.
TODO idea, implement.
-->

<h3>Special qualifier types</h3>
There are a bunch of special qualifier types. 

<h4><code>(any)</code></h4>
Just a type that is more general then any of the other types.

<h4><code>(eql single-argument)</code></h4>
<p>This one allows you to specify exactly what an argument is, or that it is some 
number exactly, and each should have it seperately.</p>
<p>If it is one exact value, it should just have that number right behind it like:
 <code>(eql 1)</code>, <code>(eql 2.4)</code>, <code>(eql 'noodle)</code>.</p>
<p>If it is an exact number, but unspecified.(Use on functions with flags like :specify-as-used)
Hou have: <code>(eql (integer n))</code>, <code>(eql (number x))</code>,
<code>(eql (symbol sym))</code></p>

<h4><code>(eql* single-argument)</code></h4>
<p>TODO Same as <code>eql</code>, excepth this one also checks non-eql types for equality. 
  This way this can work (Which would stack-overflow with eql.):</p>
<p><code>(defun factorial ((n (eql* 1))) 1)</code></p>
<p><code>(defun factorial ((n (integer))) (* n (factorial (- n 1))))</code></p>

<p>Of course, this might be better:</p>
<p><code>(defun factorial ((n (integer))) (let1 (m 1) (do-times n (i) (set- * m i))))</code></p>
<p><code> (do-times 6 (i)
   (eval `(specialize-fun factorial ((eql ,i)) :inline))) ;;Inline short ones.</code></p>

<h4><code>(or ..bunch..of..types..)</code></h4>
With this one, the type is one of the arguments of the or. These things come out of
conditional statements, like <code>cond</code>, <code>if</code>, etcetera. For speed it
might be a good idea to prevent them, or make sure the seperation is done at compile-time.
TODO make it so.

<h4><code>(function output-type arg-types)</code></h4>
These types describe functions. Their first argument is the output type of a function.

<h4><code>(function-adapt ,,)</code></h4>
A function that adapts to the types that are used. <code>(fun-of 'function-symbol)</code>
produces a function with type <code>(function-adapth (eql 'function-symbol))</code>, 
calling it is the same as just calling function-symbol directly.

<h3>Number types</h3>
There will be a bunch of different numbers. Rules are:
<ul>
  <li>Number most general real number.</li>
  <li>Fraction coarser then integer.</li>
  <li>Floating point always coarser then integer and fraction.</li>
  <li>Complex numbers are coarser then real numbers if the type of the real component
is coarser then the real number one.</li>
</ul>

TODO Only standard size integers and floating points are done.

<h3>Optimalization</h3>
I am planning to have at least macro-like optimalization. Maybe with typelike matching. 
But i am also planning to look at having equivalences and some way of estimating when to
switch equivalence.

TODO

<h3>Alternative ideas for syntax</h3>
<ul>
  <li> Sublisting, ';' starting sublisting and determining how it is, 
and '|' stopping it: <code>(defun meh (a (int); b (int)) | + a b;)</code> ->
    <code>(defun meh ((a (int)) (b (int))) (+ a b))</code>
    Requires programmer discretion in use, but looks a lot cleaner when 
used properly.</li>
  <li> XML-like marking, allows the programmer to make long s-expressions
repeat themselves so it is clear 'which hook' is closed.
<code>[namespace name] .... lots of code ....[/namespace name]</code>
I would require the user to repeat the exact same thing. Only issue i see 
with it that people might use it on overly long functions.</li>
  <li> Other types of hooks. { code } -> (progn code) However, seems silly 
just to use it on progn.. Factor (i superficially looked at it) makes its tree with 
different kinds of objects, also using '{}' to indicate arrays. I am not going to do that, 
but maybe allow: <code>{..}</code> -> <code>({} ..)</code> and <code>[..]</code> ->
 <code>([] ..)</code>.</li>.I don't really see the point though...
</ul>
